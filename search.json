[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STAT 385",
    "section": "",
    "text": "Preface\nThis are the lecture notes for STAT 385: Statistics Programming Methods, offered in the Summer of 2024 at UIUC. If you have any comments/suggestions/concerns about the notes please contact me at wjia@illinois.edu.\n1+1\n#&gt; [1] 2",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "STAT 385",
    "section": "References",
    "text": "References\n\n\n[1] Grolemund, G.\n(2014). Hands-on programming with r: Write your own functions and\nsimulations. O’Reilly Media.\n\n\n[2] Wickham, H. and\nGrolemund, G. (2017). R for data science: Import, tidy,\ntransform, visualize, and model data. O’Reilly Media.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "contents/8/intro.html",
    "href": "contents/8/intro.html",
    "title": "1  R Fundamentals",
    "section": "",
    "text": "1.1 Hello world for R\nprint('Hello world!')\n#&gt; [1] \"Hello world!\"",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#essential-concepts",
    "href": "contents/8/intro.html#essential-concepts",
    "title": "1  R Fundamentals",
    "section": "1.2 Essential concepts",
    "text": "1.2 Essential concepts\n\nIn R, assignments is &lt;-, not =. = actually works, but it may cause confusions. So it is always recommended to use &lt;-. The R Studio keybinding for &lt;- is alt+-.\n. is NOT a special character in R, and can be used in variable names. So is.na() simply means a function called is.na. It is not a function na in a package is as in Python.\nIn R, the block is defined by {}. Indentation is not that important.\nR has a better package management system than Python, and therefore in most cases you don’t need virtual environment for R.\n\n\n1.2.1 R Markdown / Quarto\nThe counterpart of Jupyter notebook in R is .rmd/.qmd file. Similar to a notebook, in a R Markdown / Quarto file, there is a so-called code block that can run the codes inside to produce documents with both texts and codes and codes outputs.\nIn the following two sections about R, you are supposed to submit .rmd/.qmd file.\n\n\n\n\n\n\nNote\n\n\n\nQuarto is an extension/continuation of R Markdown. Most R Markdown file can be directly translated to a Quarto file without many modifications. The main difference between R Markdown and Quarto is that Quarto has better support for other languages such as Python and Julia. You may go to its homepage for more details.\nThis note is produced by Quarto.\n\n\nThe most import part of R Markdown / Quarto is the code block, that is\n```{r}\nprint('Hello world!')\n```\nIn Quarto, you may also write\n```{python}\nprint('Hello world!')\n```\nThere are many options to adjust how the code blocks are excacuted. You don’t need to worry about them right now. Currently just try to write your report together with code blocks.",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#data-structures",
    "href": "contents/8/intro.html#data-structures",
    "title": "1  R Fundamentals",
    "section": "1.3 Data structures",
    "text": "1.3 Data structures\nMain reference here is [1] and [2].\n\n1.3.1 Vectors\nVector is one of the basic data structure in R. It is created by c() function. Sometimes it is called atomic vector. You may store any data types in it. R recognizes six basic types: double, integers, characters, logicals, complex and raw.\nThe data type inside a vector can be checked by typeof function.\n\ndie &lt;- c(1, 2, 3, 4, 5, 6)\ntypeof(die)\n#&gt; [1] \"double\"\n\nFor consecutive numbers, an easier way to create vector is to use :.\n\ndie &lt;- 1:6\n\n\n\n\n\n\n\nCaution\n\n\n\nNote that vector index starts from 1 in R, while list index starts from 0 in Python.\n\n\n\ndie[1]\n#&gt; [1] 1\n\nWhen slicing with vectors, don’t forget to use c().\n\ndie[c(2, 3)]\n#&gt; [1] 2 3\n\n\ndie[2:3]\n#&gt; [1] 2 3\n\nYou may use length() function to get its length.\n\nlength(die)\n#&gt; [1] 6\n\n\n\n1.3.2 Attributes\nR objects may have attributes. Attributes won’t be shown by default when you show the object. You may find the attributes of a R object by calling the attributes() function.\nThe following example show that the vector die defined in Section 1.3.1 doesn’t have attributes.\n\nattributes(die)\n#&gt; NULL\n\nAttributes can be read and write using attr function. See the following example.\n\nExample 1.1  \n\nattr(die, 'date') &lt;- '2022-01-01'\ndie\n#&gt; [1] 1 2 3 4 5 6\n#&gt; attr(,\"date\")\n#&gt; [1] \"2022-01-01\"\nattr(die, 'date') &lt;- NULL\ndie\n#&gt; [1] 1 2 3 4 5 6\n\n\nYou may think attributes as metadata attached to a R object. They are used to tell some useful infomation of the object. Some functions will interact with certain attributes. R itself treat attributes class, comment, dim, dimnames, names, row.names and tsp specially. We will only talk about class and names here. dim will be discussed in the next section. Others will be discussed when we use them.\n\nclass: This is different from the class in Python. class in R is an attribute which talks about the class of an object. If the attribute class is not assigned to an object, the object will have an implicit class: matrix, array, function, numeric or the result of typeof.\n\nattr(x, 'class') will show the “external” class of an object. You may also use class(x) to read and write attribute class. If the class is not assigned, class(x) will show the implicit class, while attr(x, 'class') will show NULL.\n\nExample 1.2  \n\nattr(die, 'class')\n#&gt; NULL\nclass(die)\n#&gt; [1] \"integer\"\nclass(die) &lt;- 'a die'\nattr(die, 'class')\n#&gt; [1] \"a die\"\nclass(die)\n#&gt; [1] \"a die\"\n\n\n\nnames: This attribute is used to name each element in a vector. After the names are assigned, it won’t be displayed below the data like other attributes. It will be displayed above the data with correct alignment. Similar to class, you may use names() to read and write the attribute.\n\n\nExample 1.3  \n\nnames(die) &lt;- c('one', 'two', 'three', 'four', 'five', 'six')\ndie\n#&gt;   one   two three  four  five   six \n#&gt;     1     2     3     4     5     6\nattributes(die)\n#&gt; $names\n#&gt; [1] \"one\"   \"two\"   \"three\" \"four\"  \"five\"  \"six\"\nnames(die)\n#&gt; [1] \"one\"   \"two\"   \"three\" \"four\"  \"five\"  \"six\"\nis.vector(die)\n#&gt; [1] TRUE\n\n\n\n\n\n\n\n\nTip\n\n\n\nWhen you store different types of data into a single vector in R, R will convert them into a single type. The default way to do so is\n\nif there are only logicals and numbers, logicals will be converted to numbers by TRUE-&gt;1 and FALSE-&gt;0.\nif characters are presented, all are converted to characters by what it is.\n\n\nc(1, TRUE)\n#&gt; [1] 1 1\nc('1', 1, TRUE)\n#&gt; [1] \"1\"    \"1\"    \"TRUE\"\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe can apply regular operators to vectors. The defaul way is to apply the operators element-wise.\n\n\n\n\n1.3.3 matrices and arrays\n\nm &lt;- matrix(c(1,2,3,4,5,6), nrow=2)\nm[1, ]\n#&gt; [1] 1 3 5\n\nA matrix has dim attribute.\n\ndim(m)\n#&gt; [1] 2 3\n\nNote that by assigning and removing dim attribute, you may change the object between vectors and matrices.\n\nExample 1.4  \n\nm\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]    1    3    5\n#&gt; [2,]    2    4    6\nis.matrix(m)\n#&gt; [1] TRUE\nis.vector(m)\n#&gt; [1] FALSE\ndim(m)\n#&gt; [1] 2 3\ndim(m) &lt;- NULL\nm\n#&gt; [1] 1 2 3 4 5 6\nis.matrix(m)\n#&gt; [1] FALSE\nis.vector(m)\n#&gt; [1] TRUE\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe dim of a matrix/vector can be a long vector. In this case, it will become an array.\n\n\n\n\n1.3.4 factors\nFactor is speical vector. It is a way to handle categorical data. The idea is the limit the possible values. In a factor all possible values are called level, which is an attribute.\n\nExample 1.5 We would like to talk about all months. We first define a vector of the valid levels:\n\nmonth_levels &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\n\nThen we could start to transform some month vector into factors, by the function factor().\n\nx1 &lt;- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\ny1 &lt;- factor(x1, level=month_levels)\nsort(x1)\n#&gt; [1] \"Apr\" \"Dec\" \"Jan\" \"Mar\"\nsort(y1)\n#&gt; [1] Jan Mar Apr Dec\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nNote that sorting y1 is based on the levels.\n\nx2 &lt;- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\ny2 &lt;- factor(x2, level=month_levels)\ny2\n#&gt; [1] Dec  Apr  &lt;NA&gt; Mar \n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nNote that y2 contains NA value since there is an entry in x2 that is not valid.\n\n\n\n1.3.5 Lists\nList is very similar to a vector. The main difference is that vector can only store values, while list can store objects. The most typical example of objects is another vector. Please see the following example.\n\nExample 1.6  \n\nc(1:2, 3:4)\n#&gt; [1] 1 2 3 4\nlist(1:2, 3:4)\n#&gt; [[1]]\n#&gt; [1] 1 2\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 3 4\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe attributes of an object is stored in an array.\n\nm &lt;- matrix(c(1,2,3,4,5,6), nrow=2)\na &lt;- attributes(m)\nclass(a)\n#&gt; [1] \"list\"\n\n\n\n\n\n1.3.6 data.frame\nData.Frame is a list with the class attribute data.frame, together with some restriction on the shape of each columns. You may think about it in terms of tables.\n\ndf &lt;- data.frame(face = c(\"ace\", \"two\", \"six\"),\n                 suit = c(\"clubs\", \"clubs\", \"clubs\"),\n                 value = c(1, 2, 3))\ndf\n#&gt;   face  suit value\n#&gt; 1  ace clubs     1\n#&gt; 2  two clubs     2\n#&gt; 3  six clubs     3\n\n\nData Frame group vectors. Each vector represents a column.\nDifferent column can contain a different type of data, but every cell within one column must be the same type of data.\ndata.frame() can be used to create a data.frame.\nThe type of a data.frame is a list. Similar to matrix comparing to vector, a data.frame is a list with class data.frame, as well as a few other attributes.\n\n\n\n1.3.7 Examples\n\nExample 1.7 Consider a date.frame representing a deck of cards. Here we use expand.grid() to perform the Cartesian product.\n\nsuit &lt;- c('spades', 'hearts', 'clubs', 'diamonds')\nface &lt;- 1:13\ndeck &lt;- expand.grid(suit, face)\nhead(deck)\n#&gt;       Var1 Var2\n#&gt; 1   spades    1\n#&gt; 2   hearts    1\n#&gt; 3    clubs    1\n#&gt; 4 diamonds    1\n#&gt; 5   spades    2\n#&gt; 6   hearts    2\n\nWe may assign names to change the column names.\n\nnames(deck) &lt;- c('suit', 'face')\nhead(deck)\n#&gt;       suit face\n#&gt; 1   spades    1\n#&gt; 2   hearts    1\n#&gt; 3    clubs    1\n#&gt; 4 diamonds    1\n#&gt; 5   spades    2\n#&gt; 6   hearts    2\n\nNote that since suit and face are two vectors, merge() can also do the Cartesian product. expand.grid() is good for both vectors and data.frame.\n\ndeck &lt;- merge(suit, face)\nhead(deck)\n#&gt;          x y\n#&gt; 1   spades 1\n#&gt; 2   hearts 1\n#&gt; 3    clubs 1\n#&gt; 4 diamonds 1\n#&gt; 5   spades 2\n#&gt; 6   hearts 2\n\n\n\n\n1.3.8 Load data\n\n1.3.8.1 build-in datasets\nR has many build-in datasets. You may use data() to see all of them. Here are a few common datasets.\n\nmtcars: Motor Trend Car Road Tests: The data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973–74 models)\n\n\ndata(mtcars)\n\n\niris: iris data set gives the measurements in centimeters of the variables sepal length, sepal width, petal length and petal width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica.\n\n\ndata(iris)\n\n\nToothGrowth: ToothGrowth data set contains the result from an experiment studying the effect of vitamin C on tooth growth in 60 Guinea pigs.\n\n\ndata(ToothGrowth)\n\n\nPlantGrowth: Results obtained from an experiment to compare yields (as measured by dried weight of plants) obtained under a control and two different treatment condition.\n\n\ndata(PlantGrowth)\n\n\nUSArrests: This data set contains statistics about violent crime rates by us state.\n\n\ndata(USArrests)\n\n\n\n1.3.8.2 Read from files\nThe build-in read.csv() function can directly read .csv file into a data.frame.\n\nExample 1.8 We use the file yob1880.txt from Chapter 5 here. Put the file in the working folder and run the following code.\n\ndf &lt;- read.csv('yob1880.txt', header = FALSE)\nhead(df)\n\nWe may also manually assign columns names.\n\nnames(df) &lt;- c('name', 'sex', 'counts')\nhead(df)\n#&gt;        name sex counts\n#&gt; 1      Mary   F   7065\n#&gt; 2      Anna   F   2604\n#&gt; 3      Emma   F   2003\n#&gt; 4 Elizabeth   F   1939\n#&gt; 5    Minnie   F   1746\n#&gt; 6  Margaret   F   1578\n\n\n\n\n\n\n\n\nNote\n\n\n\nTo save data is straightforward.\n\nwrite.csv(df, file='df.csv', row.names=FALSE)\n\n\n\n\n\n\n1.3.9 Flow control\n\n1.3.9.1 for loop\n\nExample 1.9  \n\nfor (x in 1:10){\n    print(x)\n}\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n#&gt; [1] 6\n#&gt; [1] 7\n#&gt; [1] 8\n#&gt; [1] 9\n#&gt; [1] 10\n\n\n\n\n1.3.9.2 if-else\n\nExample 1.10  \n\na &lt;- 200\nb &lt;- 33\n\nif (b &gt; a) {\n  print(\"b is greater than a\")\n} else if (a == b) {\n  print(\"a and b are equal\")\n} else {\n  print(\"a is greater than b\")\n}\n#&gt; [1] \"a is greater than b\"\n\n\n\n\n1.3.9.3 Functions\nThe standard format to define a function is my_function &lt;- function(input) {} where the function name is on the left side of &lt;-, the input arguments are in the (), and the function body is in {}. The output of the last line of the function body is the return value of the function.\n\nExample 1.11  \n\nmyfunction &lt;- function() {\n    die &lt;- 1:6\n    sum(die)\n}\n\nmyfunction()\n#&gt; [1] 21\n\nIf you just type the function name without (), R will return the definition of the function.\n\nmyfunction\n#&gt; function() {\n#&gt;     die &lt;- 1:6\n#&gt;     sum(die)\n#&gt; }\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe function sample(x): sample takes a sample of the specified size from the elements of x using either with or without replacement.\nsample(x, size, replace = FALSE, prob = NULL):\n\nx: either a vector of one or more elements from which to choose, or a positive integer.\nsize: a non-negative integer giving the number of items to choose.\nreplace: should sampling be with replacement?\nprob: a vector of probability weights for obtaining the elements of the vector being sampled.",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#r-notations",
    "href": "contents/8/intro.html#r-notations",
    "title": "1  R Fundamentals",
    "section": "1.4 R notations",
    "text": "1.4 R notations\n\n1.4.1 Selecting Values\nLet us start from a data.frame df. The basic usage is df[ , ], where the first index is to subset the rows and the second index is to subset the columns. There are six ways to writing indexes.\n\nPositive integers: the regular way.\n\n\ndf[i, j] means the data in the ith row and jth column.\nIf both i and j are vectors, a data.frame will be returned.\nIf i or j are a vector, a vector will be returned. If you still want a data.frame, you may add the option drop=FALSE.\nIf only one index is provided, it refers to the column.\n\n\nExample 1.12 We consider the simplified version of a deck. The deck only contains face values from 1 to 5.\n\ndeck[1:2, 1:2]\n#&gt;     Var1 Var2\n#&gt; 1 spades    1\n#&gt; 2 hearts    1\ndeck[1:2, 1]\n#&gt; [1] spades hearts\n#&gt; Levels: spades hearts clubs diamonds\ndeck[1:2, 1, drop=FALSE]\n#&gt;     Var1\n#&gt; 1 spades\n#&gt; 2 hearts\ndeck[1]\n#&gt;        Var1\n#&gt; 1    spades\n#&gt; 2    hearts\n#&gt; 3     clubs\n#&gt; 4  diamonds\n#&gt; 5    spades\n#&gt; 6    hearts\n#&gt; 7     clubs\n#&gt; 8  diamonds\n#&gt; 9    spades\n#&gt; 10   hearts\n#&gt; 11    clubs\n#&gt; 12 diamonds\n#&gt; 13   spades\n#&gt; 14   hearts\n#&gt; 15    clubs\n#&gt; 16 diamonds\n#&gt; 17   spades\n#&gt; 18   hearts\n#&gt; 19    clubs\n#&gt; 20 diamonds\n\n\n\nNegative integers: remove the related index.\n\nFor example,\n\ndeck[-1, 1:3] means it wants all rows except row 1, and column 1 to 3.\ndeck[-(2:20), 1:2] means it wants all rows ecepte row 2 to row 20, and column 1 to 2.\nNegative index and positive index cannot be used together in the same index.\n\n\nBlank Spaces: want every value in the dimension.\n\n\ndeck[, 1]\n#&gt;  [1] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt;  [9] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt; [17] spades   hearts   clubs    diamonds\n#&gt; Levels: spades hearts clubs diamonds\ndeck[1, ]\n#&gt;     Var1 Var2\n#&gt; 1 spades    1\n\n\nLogical values: select the rows or columns according to the value. The dimension should have exactly the same number of elements as the logical vector.\n\n\nrows &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE)\ndeck[rows,]\n#&gt;        Var1 Var2\n#&gt; 1    spades    1\n#&gt; 3     clubs    1\n#&gt; 5    spades    2\n#&gt; 6    hearts    2\n#&gt; 8  diamonds    2\n#&gt; 10   hearts    3\n#&gt; 11    clubs    3\n#&gt; 13   spades    4\n#&gt; 15    clubs    4\n#&gt; 16 diamonds    4\n#&gt; 18   hearts    5\n#&gt; 20 diamonds    5\ndeck[1:2, c(TRUE, FALSE)]\n#&gt; [1] spades hearts\n#&gt; Levels: spades hearts clubs diamonds\n\n\nNames: select columns based on names attribute.\n\n\ndeck[, 'Var2']\n#&gt;  [1] 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5\n\n\n\n1.4.2 Dollar signs and double brackets\nList and data.frame obey an optional second system of notation. You can extract values using $ syntax: the data.frame’s name and the column name separated by a $ will select a column and return a vector (since the data in each column is actually a vector).\n\nExample 1.13 Here is an exmaple about data.frames.\n\ndeck[, 1]\n#&gt;  [1] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt;  [9] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt; [17] spades   hearts   clubs    diamonds\n#&gt; Levels: spades hearts clubs diamonds\ndeck$Var1\n#&gt;  [1] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt;  [9] spades   hearts   clubs    diamonds spades   hearts   clubs    diamonds\n#&gt; [17] spades   hearts   clubs    diamonds\n#&gt; Levels: spades hearts clubs diamonds\n\nNote that if we select from the data.frame using index, we will get a data.frame.\n\ndeck[1]\n#&gt;        Var1\n#&gt; 1    spades\n#&gt; 2    hearts\n#&gt; 3     clubs\n#&gt; 4  diamonds\n#&gt; 5    spades\n#&gt; 6    hearts\n#&gt; 7     clubs\n#&gt; 8  diamonds\n#&gt; 9    spades\n#&gt; 10   hearts\n#&gt; 11    clubs\n#&gt; 12 diamonds\n#&gt; 13   spades\n#&gt; 14   hearts\n#&gt; 15    clubs\n#&gt; 16 diamonds\n#&gt; 17   spades\n#&gt; 18   hearts\n#&gt; 19    clubs\n#&gt; 20 diamonds\nclass(deck[1])\n#&gt; [1] \"data.frame\"\n\n\n\nExample 1.14 Here is an example about lists.\n\nlst &lt;- list(numbers = c(1, 2), logical = TRUE, strings = c(\"a\", \"b\", \"c\"))\nlst$numbers\n#&gt; [1] 1 2\n\nNote that if we select from the list using index, we will get a list.\n\nlst[1]\n#&gt; $numbers\n#&gt; [1] 1 2\nclass(lst[1])\n#&gt; [1] \"list\"\n\n\nPlease think through these two examples and figure out the similarity between them.\n\n\n\n\n\n\nCaution\n\n\n\nUnderstanding the return value type is very important. Many of the R function work with vectors, but they don’t work with lists. So using the correct way to get values is very important.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThere is a command called attach() which let you get access to deck$face by just typing face. It is highly recommanded NOT to do this. It is much better to make everything explicit, especially when using IDE, typing is much easier.",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#modifying-values",
    "href": "contents/8/intro.html#modifying-values",
    "title": "1  R Fundamentals",
    "section": "1.5 Modifying values",
    "text": "1.5 Modifying values\n\n1.5.1 Changing values in place\nYou can use R’s notation system to modify values within an R object.\n\nIn general when working with vectors, the two vectors should have the same length.\nIf the lengths are different, R will repeat the shorter one to make it match with the longer one. This is called the vector recycling rule. R will throw a warning if the two lengths are not proposional.\n\n\nExample 1.15  \n\n1:4 + 1:2\n#&gt; [1] 2 4 4 6\n1:4 + 1:3\n#&gt; Warning in 1:4 + 1:3: longer object length is not a multiple of shorter object\n#&gt; length\n#&gt; [1] 2 4 6 5\n\n\n\nWe may create values that do not yet exist in the object. R will expand the object to accommodate the new values.\n\n\nExample 1.16  \n\nvec &lt;- 1:6\nvec\n#&gt; [1] 1 2 3 4 5 6\nvec[7] &lt;- 0\nvec\n#&gt; [1] 1 2 3 4 5 6 0\n\n\n\nExample 1.17  \n\ndf &lt;- data.frame(a=c(1,2), b=c('a', 'b'))\ndf\n#&gt;   a b\n#&gt; 1 1 a\n#&gt; 2 2 b\ndf$c &lt;- 3:4\ndf\n#&gt;   a b c\n#&gt; 1 1 a 3\n#&gt; 2 2 b 4\n\n\n\n\n1.5.2 Logical subsetting\nWe could compare two vectors element-wise, and the result is a logical vector. Then we could use this result to subset the vector / data.frame.\n\nExample 1.18  \n\nsuit &lt;- c('spades', 'hearts', 'clubs', 'diamonds')\nface &lt;- 1:5\ndeck &lt;- expand.grid(suit, face)\n\n\ndeck$Var1 == 'hearts'\n#&gt;  [1] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n#&gt; [13] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\ndeck$Var2[deck$Var1 == 'hearts']\n#&gt; [1] 1 2 3 4 5\ndeck[deck$Var1 == 'hearts',]\n#&gt;      Var1 Var2\n#&gt; 2  hearts    1\n#&gt; 6  hearts    2\n#&gt; 10 hearts    3\n#&gt; 14 hearts    4\n#&gt; 18 hearts    5\n\nWe could directly assign values to the subset. Note that the following assignment create a new column with NA values.\n\ndeck$Var3[deck$Var1 == 'hearts'] &lt;- 1\ndeck\n#&gt;        Var1 Var2 Var3\n#&gt; 1    spades    1   NA\n#&gt; 2    hearts    1    1\n#&gt; 3     clubs    1   NA\n#&gt; 4  diamonds    1   NA\n#&gt; 5    spades    2   NA\n#&gt; 6    hearts    2    1\n#&gt; 7     clubs    2   NA\n#&gt; 8  diamonds    2   NA\n#&gt; 9    spades    3   NA\n#&gt; 10   hearts    3    1\n#&gt; 11    clubs    3   NA\n#&gt; 12 diamonds    3   NA\n#&gt; 13   spades    4   NA\n#&gt; 14   hearts    4    1\n#&gt; 15    clubs    4   NA\n#&gt; 16 diamonds    4   NA\n#&gt; 17   spades    5   NA\n#&gt; 18   hearts    5    1\n#&gt; 19    clubs    5   NA\n#&gt; 20 diamonds    5   NA\n\n\n\n\n\n\n\n\nTip\n\n\n\nOther than the regualr logical operators, R provides a speical one: %in%.\nx %in% y: Is x in the vector y?\nIf x is a vector, the output is a vector with the same length as x, telling whether each element of x is in y or not.\n\n\n\n\n\n\n\n\nTip\n\n\n\nOther than the regular Boolean operators, R provides two special ones: any and all.\n\nany(cond1, cond2, ...): Are any of these conditions true?\nall(cond1, cond2, ...): Are all of these conditions true?\n\n\n\n\n\n1.5.3 Missing values NA\nIn R, missing values are NA, and you can directly work with NA. Any computations related to NA will return NA.\n\nna.rm: Most R functions come with the optional argument na.rm. If you set it to be TRUE, the function will ignore NA when evaluating the function.\n\n\nExample 1.19  \n\nmean(c(NA, 1:50))\n#&gt; [1] NA\nmean(c(NA, 1:50), na.rm=TRUE)\n#&gt; [1] 25.5\n\n\n\nis.na(): This is a function testing whether an object is NA.",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/8/intro.html#exercises",
    "href": "contents/8/intro.html#exercises",
    "title": "1  R Fundamentals",
    "section": "1.6 Exercises",
    "text": "1.6 Exercises\n\nExercise 1.1 Start a R Markdown / Quarto file. In the first section write a R code block to print Hello world!.\n\n\nExercise 1.2 Which of these are character strings and which are numbers? 1, \"1\", \"one\".\n\n\nExercise 1.3 Create an atomic vector that stores just the face names of the cards: the ace of spades, king of spades, queen of spades, jack of spades, and ten of spades. Which type of vector will you use to save the names?\nHint: The face name of the ace of spades would be ace and spades is the suit.\n\n\nExercise 1.4 Create the following matrix, which stores the name and suit of every card in a royal flush.\n\n#&gt;      [,1]    [,2]    \n#&gt; [1,] \"ace\"   \"spades\"\n#&gt; [2,] \"king\"  \"spades\"\n#&gt; [3,] \"queen\" \"spades\"\n#&gt; [4,] \"jack\"  \"spades\"\n#&gt; [5,] \"ten\"   \"spades\"\n\n\n\nExercise 1.5 Many card games assign a numerical value to each card. For example, in blackjack, each face card is worth 10 points, each number card is worth between 2 and 10 points, and each ace is worth 1 or 11 points, depending on the final score.\nMake a virtual playing card by combining “ace” “heart” and 1 into a vector. What type of atomic vector will result? Check if you are right, and explain your reason.\n\n\nExercise 1.6 Use a list to store a single playing card, like the ace of hearts, which has a point value of one. The list should save the face of the card, the suit, and the point value in separate elements.\n\n\nExercise 1.7 Consider the following data.frame.\n\nsuit &lt;- c('spades', 'hearts', 'clubs', 'diamonds')\nface &lt;- 1:5\ndeck &lt;- expand.grid(suit, face)\n\nPlease write some codes to count how many rows whose Var1 are equal to hearts.\n\n\nExercise 1.8 Converte the following sentences into tests written with R code.\n\nw &lt;- c(-1, 0, 1). Is w positive?\nx &lt;- c(5, 15). Is x greater than 10 and less than 20?\ny &lt;- 'February'. Is object y the word February?\nz &lt;- c(\"Monday\", \"Tuesday\", \"Friday\"). Is every value in z a day of the week?\n\n\n\nExercise 1.9 Please write a function to shuffle the row of a data.frame. You may use the following data.frame deck for test.\n\nsuit &lt;- c('spades', 'hearts', 'clubs', 'diamonds')\nface &lt;- 1:13\ndeck &lt;- expand.grid(suit, face)\n\n\n\n\n\n\n[1] Grolemund, G. (2014). Hands-on programming with r: Write your own functions and simulations. O’Reilly Media.\n\n\n[2] Wickham, H. and Grolemund, G. (2017). R for data science: Import, tidy, transform, visualize, and model data. O’Reilly Media.",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R Fundamentals</span>"
    ]
  },
  {
    "objectID": "contents/9/intro.html",
    "href": "contents/9/intro.html",
    "title": "2  R for Data Sciences",
    "section": "",
    "text": "2.1 tibble\ntidyverse mainly deals with tibble instead of data.frame. Therefore this is where we start.\ntibble is a data.frame with different attributes and requirements. The package tibble provides support for tibble. It is included in tidyverse. To load it, you just use the code:\nlibrary(tidyverse)\n#&gt; Warning: package 'tidyverse' was built under R version 4.1.3\n#&gt; Warning: package 'tibble' was built under R version 4.1.3\n#&gt; Warning: package 'tidyr' was built under R version 4.1.3\n#&gt; Warning: package 'readr' was built under R version 4.1.3\n#&gt; Warning: package 'purrr' was built under R version 4.1.3\n#&gt; Warning: package 'dplyr' was built under R version 4.1.3\n#&gt; Warning: package 'stringr' was built under R version 4.1.3\n#&gt; Warning: package 'forcats' was built under R version 4.1.3\n#&gt; -- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\n#&gt; v dplyr     1.1.1     v readr     2.1.4\n#&gt; v forcats   1.0.0     v stringr   1.5.0\n#&gt; v ggplot2   3.4.4     v tibble    3.2.1\n#&gt; v lubridate 1.9.3     v tidyr     1.3.0\n#&gt; v purrr     1.0.1     \n#&gt; -- Conflicts ------------------------------------------ tidyverse_conflicts() --\n#&gt; x dplyr::filter() masks stats::filter()\n#&gt; x dplyr::lag()    masks stats::lag()\n#&gt; i Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R for Data Sciences</span>"
    ]
  },
  {
    "objectID": "contents/9/intro.html#tibble",
    "href": "contents/9/intro.html#tibble",
    "title": "2  R for Data Sciences",
    "section": "",
    "text": "2.1.1 Create tibbles\nHere is an example of creating tibbles.\n\nExample 2.1  \n\ntbl &lt;- tibble(x=1:5, y=1, z=x^2+y)\ntbl\n#&gt; # A tibble: 5 x 3\n#&gt;       x     y     z\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     1     2\n#&gt; 2     2     1     5\n#&gt; 3     3     1    10\n#&gt; 4     4     1    17\n#&gt; 5     5     1    26\nattributes(tbl)\n#&gt; $class\n#&gt; [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#&gt; \n#&gt; $row.names\n#&gt; [1] 1 2 3 4 5\n#&gt; \n#&gt; $names\n#&gt; [1] \"x\" \"y\" \"z\"\n\nNote that it is more flexible to create a tibble since tibble() will automatically recycle inputs and allows you to refer to variables that you just created.\n\n\n\n\n\n\n\nNote\n\n\n\nIn the past (for a very long time), when using data.frame() to create a data.frame, it will automatically convert strings to factors. This is changed recently that the default setting is not to convert.\nWhen using tibble() to create a tibble, the type of the inputs will never be changed.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn tibble you may use nonsyntactic names as column names, which are invalid R variable names. To refer to these variables, you need to surround them with backticks `.\n\ntb &lt;- tibble(\n    `:)` = \"smile\",\n    ` ` = \"space\",\n    `2000` = \"number\"\n)\ntb\n#&gt; # A tibble: 1 x 3\n#&gt;   `:)`  ` `   `2000`\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; \n#&gt; 1 smile space number\n\n\n\n\n\n2.1.2 Differences between tibble and data.frame.\n\n2.1.2.1 Printing\nTibbles have a refined print method that shows only the first 10 rows and all the columns that fit on screen.\n\ndeck &lt;- tibble(suit=rep(c('spades', 'hearts', 'clubs', 'diamonds'), 13), face=rep(1:13, 4))\ndeck\n#&gt; # A tibble: 52 x 2\n#&gt;    suit      face\n#&gt;    &lt;chr&gt;    &lt;int&gt;\n#&gt;  1 spades       1\n#&gt;  2 hearts       2\n#&gt;  3 clubs        3\n#&gt;  4 diamonds     4\n#&gt;  5 spades       5\n#&gt;  6 hearts       6\n#&gt;  7 clubs        7\n#&gt;  8 diamonds     8\n#&gt;  9 spades       9\n#&gt; 10 hearts      10\n#&gt; # i 42 more rows\n\n\n\n2.1.2.2 Subsetting\nTo get a single value, [[]] or $ should be used, just like for data.frame. These two are almost the same. The only difference is that [[]] accepts positions, but $ only accepts names.\nTo be used in a pipe, the special placeholder . will be used.\n\ndeck %&gt;% .$face\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13  1  2  3  4  5  6  7  8  9 10 11 12\n#&gt; [26] 13  1  2  3  4  5  6  7  8  9 10 11 12 13  1  2  3  4  5  6  7  8  9 10 11\n#&gt; [51] 12 13\n\nWe will talk about pipes later.\n\n\n\n2.1.3 %&gt;% symbol\n%&gt;% is the pipeline symbol, which is another way to connect several functions. Most functions in tidyverse have the first argument data, and both the input data and the output are tibbles. The syntax here is that data %&gt;% function(arguments) is the same as function(data, arguments). The benefit is that it is easier to have many functions consecutively applied to the data. Please see the following example.\n\ndata %&gt;% function1(arguments1)\n    %&gt;% function2(arguments2)\n    %&gt;% function3(arguments3)\n    %&gt;% function4(arguments4)\n\nfunction4(function3(function2(function1(data, arguments1), arguments2), arguments3), arguments4)\n\ndata2 &lt;- function1(data, arguments1)\ndata3 &lt;- function2(data2, arguments2)\ndata4 &lt;- function3(data3, arguments3)\nfunction4(data4, arguments4)\n\nThe readability of the first one is much better than the second one. Comparing to the third one, we don’t need to create a lot of intermedia temporary variables.",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R for Data Sciences</span>"
    ]
  },
  {
    "objectID": "contents/9/intro.html#tidy-data",
    "href": "contents/9/intro.html#tidy-data",
    "title": "2  R for Data Sciences",
    "section": "2.2 Tidy Data",
    "text": "2.2 Tidy Data\nThe same underlying data can be represented in multiple ways. The following example shows the same data organized in four different ways.\n\nExample 2.2 These tibbles are provided by tidyr. You could directly load it from tidyverse.\n\nlibrary(tidyverse)\ndata(table1, package='tidyr')\ndata(table2, package='tidyr')\ndata(table3, package='tidyr')\ndata(table4a, package='tidyr')\ndata(table4b, package='tidyr')\n\n\ntable1\n\n\ntable1\n#&gt; # A tibble: 6 x 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\n\ntable2\n\n\ntable2\n#&gt; # A tibble: 12 x 4\n#&gt;    country      year type            count\n#&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n#&gt;  1 Afghanistan  1999 cases             745\n#&gt;  2 Afghanistan  1999 population   19987071\n#&gt;  3 Afghanistan  2000 cases            2666\n#&gt;  4 Afghanistan  2000 population   20595360\n#&gt;  5 Brazil       1999 cases           37737\n#&gt;  6 Brazil       1999 population  172006362\n#&gt;  7 Brazil       2000 cases           80488\n#&gt;  8 Brazil       2000 population  174504898\n#&gt;  9 China        1999 cases          212258\n#&gt; 10 China        1999 population 1272915272\n#&gt; 11 China        2000 cases          213766\n#&gt; 12 China        2000 population 1280428583\n\n\ntable3\n\n\ntable3\n#&gt; # A tibble: 6 x 3\n#&gt;   country      year rate             \n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;            \n#&gt; 1 Afghanistan  1999 745/19987071     \n#&gt; 2 Afghanistan  2000 2666/20595360    \n#&gt; 3 Brazil       1999 37737/172006362  \n#&gt; 4 Brazil       2000 80488/174504898  \n#&gt; 5 China        1999 212258/1272915272\n#&gt; 6 China        2000 213766/1280428583\n\n\nSpread across two tibbles.\n\n\ntable4a\n#&gt; # A tibble: 3 x 3\n#&gt;   country     `1999` `2000`\n#&gt;   &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Afghanistan    745   2666\n#&gt; 2 Brazil       37737  80488\n#&gt; 3 China       212258 213766\n\ntable4b\n#&gt; # A tibble: 3 x 3\n#&gt;   country         `1999`     `2000`\n#&gt;   &lt;chr&gt;            &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan   19987071   20595360\n#&gt; 2 Brazil       172006362  174504898\n#&gt; 3 China       1272915272 1280428583\n\n\n\nDefinition 2.1 A dataset is tidy if\n\nEach variable have its own column.\nEach observation have its own row.\nEach value have its oven cell.\n\n\nThese three conditions are interrelated because it is impossible to only satisfy two of the three. In pratical, we need to follow the instructions:\n\nPut each dataset in a tibble.\nPut each variable in a column.\n\nTidy data is a consistent way to organize your data in R. The main advantages are:\n\nIt is one consistent way of storing data. In other words, this is a consistent data structure that can be used in many cases.\nTo placing variables in columns allows R’s vectorized nature to shine.\n\nAll packages in the tidyverse are designed to work with tidy data.\n\n2.2.1 Tidying datasets\nMost datasets are untidy:\n\nOne variable might be spread across multiple columns.\nOne observation might be scattered across multiple rows.\n\n\n2.2.1.1 pivot_longer()\nA common problem is that the column names are not names of variables, but values of a variable. For example, table4a above has columns 1999 and 2000. These two names are actually the values of a variable year. In addition, each row represents two observations, not one.\n\ntable4a\n#&gt; # A tibble: 3 x 3\n#&gt;   country     `1999` `2000`\n#&gt;   &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Afghanistan    745   2666\n#&gt; 2 Brazil       37737  80488\n#&gt; 3 China       212258 213766\n\nTo tidy this type of dataset, we need to gather those columns into a new pair of variables. We need three parameters:\n\nThe set of columns that represent values. In this case, those are 1999 and 2000.\nThe name of the variable. In this case, it is year. -The name of the variable whose values are spread over the cells. In this case, it is the number of cases.\n\nThen we apply pivot_longer().\n\npivot_longer(table4a, cols=c(`1999`, `2000`), names_to='year', values_to='cases')\n#&gt; # A tibble: 6 x 3\n#&gt;   country     year   cases\n#&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 Afghanistan 1999     745\n#&gt; 2 Afghanistan 2000    2666\n#&gt; 3 Brazil      1999   37737\n#&gt; 4 Brazil      2000   80488\n#&gt; 5 China       1999  212258\n#&gt; 6 China       2000  213766\n\nWe may also use the pipe %&gt;% symbol.\n\ntable4a %&gt;% pivot_longer(cols=c(`1999`, `2000`), names_to='year', values_to='cases')\n#&gt; # A tibble: 6 x 3\n#&gt;   country     year   cases\n#&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 Afghanistan 1999     745\n#&gt; 2 Afghanistan 2000    2666\n#&gt; 3 Brazil      1999   37737\n#&gt; 4 Brazil      2000   80488\n#&gt; 5 China       1999  212258\n#&gt; 6 China       2000  213766\n\nWe can do the similar thing to table4b. Then we could combine the two tibbles together.\n\ntidy4a &lt;- table4a %&gt;% \n    pivot_longer(cols=c(`1999`, `2000`), names_to='year', values_to='cases')\ntidy4b &lt;- table4b %&gt;% \n    pivot_longer(cols=c(`1999`, `2000`), names_to='year', values_to='population')\nleft_join(tidy4a, tidy4b)\n#&gt; Joining with `by = join_by(country, year)`\n#&gt; # A tibble: 6 x 4\n#&gt;   country     year   cases population\n#&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan 1999     745   19987071\n#&gt; 2 Afghanistan 2000    2666   20595360\n#&gt; 3 Brazil      1999   37737  172006362\n#&gt; 4 Brazil      2000   80488  174504898\n#&gt; 5 China       1999  212258 1272915272\n#&gt; 6 China       2000  213766 1280428583\n\npivot_longer() is an updated approach to gather(), designed to be both simpler to use and to handle more use cases. We recommend you use pivot_longer() for new code; gather() isn’t going away but is no longer under active development.\n\n\n2.2.1.2 pivot_wider()\nAnother issuse is that an observation is scattered across multiple rows. Take table2 as an example. An observation is a country in a year, but each observation is spread across two rows.\n\ntable2\n#&gt; # A tibble: 12 x 4\n#&gt;    country      year type            count\n#&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n#&gt;  1 Afghanistan  1999 cases             745\n#&gt;  2 Afghanistan  1999 population   19987071\n#&gt;  3 Afghanistan  2000 cases            2666\n#&gt;  4 Afghanistan  2000 population   20595360\n#&gt;  5 Brazil       1999 cases           37737\n#&gt;  6 Brazil       1999 population  172006362\n#&gt;  7 Brazil       2000 cases           80488\n#&gt;  8 Brazil       2000 population  174504898\n#&gt;  9 China        1999 cases          212258\n#&gt; 10 China        1999 population 1272915272\n#&gt; 11 China        2000 cases          213766\n#&gt; 12 China        2000 population 1280428583\n\nWe could apply pivot_wider() to make it tidy. Here we need two arguments.\n\nThe column that contains variable names. Here, it’s type.\nThe column that contains values forms multiple variables. Here, it’s count.\n\n\npivot_wider(table2, names_from='type', values_from='count')\n#&gt; # A tibble: 6 x 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\nWe can also use the pipe symbol %&gt;%.\n\ntable2 %&gt;% pivot_wider(names_from='type', values_from='count')\n#&gt; # A tibble: 6 x 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\npivot_wider() is an updated approach to spread(), designed to be both simpler to use and to handle more use cases. We recommend you use pivot_wider() for new code; spread() isn’t going away but is no longer under active development.\n\n\n2.2.1.3 separate()\nIf we would like to split one columns into multiple columns since there are more than one values in a cell, we could use separate().\n\nseparate(table3, rate, into=c('cases', 'population'))\n#&gt; # A tibble: 6 x 4\n#&gt;   country      year cases  population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     \n#&gt; 1 Afghanistan  1999 745    19987071  \n#&gt; 2 Afghanistan  2000 2666   20595360  \n#&gt; 3 Brazil       1999 37737  172006362 \n#&gt; 4 Brazil       2000 80488  174504898 \n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\nWe could also use the pipe symbol %&gt;%.\n\ntable3 %&gt;% separate(rate, into=c('cases', 'population'))\n#&gt; # A tibble: 6 x 4\n#&gt;   country      year cases  population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     \n#&gt; 1 Afghanistan  1999 745    19987071  \n#&gt; 2 Afghanistan  2000 2666   20595360  \n#&gt; 3 Brazil       1999 37737  172006362 \n#&gt; 4 Brazil       2000 80488  174504898 \n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\nUsing separate, the first argument is the column to be separated. into is where you store the parsed data. If no arguments are given, separate() will split values wherever it sees a non-alphanumeric character. If you would like to specify a separator, you may use the sep argument.\n\nIf sep is set to be a character, the column will be separated by the character.\nIf sep is set to be a vector of integers, the column will be separated by the positions.\n\n\nseparate(table3, rate, into=c('cases', 'population'), sep='/')\n#&gt; # A tibble: 6 x 4\n#&gt;   country      year cases  population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;     \n#&gt; 1 Afghanistan  1999 745    19987071  \n#&gt; 2 Afghanistan  2000 2666   20595360  \n#&gt; 3 Brazil       1999 37737  172006362 \n#&gt; 4 Brazil       2000 80488  174504898 \n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\n\nseparate(table3, rate, into=c('cases', 'population'), sep=c(2,5))\n#&gt; # A tibble: 6 x 4\n#&gt;   country      year cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     \n#&gt; 1 Afghanistan  1999 74    5/1       \n#&gt; 2 Afghanistan  2000 26    66/       \n#&gt; 3 Brazil       1999 37    737       \n#&gt; 4 Brazil       2000 80    488       \n#&gt; 5 China        1999 21    225       \n#&gt; 6 China        2000 21    376\n\nNote that in this example, since into only has two columns, the rest of the data are lost.\nAnother useful argument is convert. After separation, the columns are still character columns. If we set convert=TRUE, the columns will be automatically converted into better types if possible.\n\nseparate(table3, rate, into=c('cases', 'population'), convert=TRUE)\n#&gt; # A tibble: 6 x 4\n#&gt;   country      year  cases population\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;int&gt;      &lt;int&gt;\n#&gt; 1 Afghanistan  1999    745   19987071\n#&gt; 2 Afghanistan  2000   2666   20595360\n#&gt; 3 Brazil       1999  37737  172006362\n#&gt; 4 Brazil       2000  80488  174504898\n#&gt; 5 China        1999 212258 1272915272\n#&gt; 6 China        2000 213766 1280428583\n\n\n\n2.2.1.4 unite()\nunite() is the inverse of separate(). The syntax is straghtforward. The default separator is _.\n\ntable3 %&gt;% unite(new, year, rate, sep='_')\n#&gt; # A tibble: 6 x 2\n#&gt;   country     new                   \n#&gt;   &lt;chr&gt;       &lt;chr&gt;                 \n#&gt; 1 Afghanistan 1999_745/19987071     \n#&gt; 2 Afghanistan 2000_2666/20595360    \n#&gt; 3 Brazil      1999_37737/172006362  \n#&gt; 4 Brazil      2000_80488/174504898  \n#&gt; 5 China       1999_212258/1272915272\n#&gt; 6 China       2000_213766/1280428583",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R for Data Sciences</span>"
    ]
  },
  {
    "objectID": "contents/9/intro.html#dplyr",
    "href": "contents/9/intro.html#dplyr",
    "title": "2  R for Data Sciences",
    "section": "2.3 dplyr",
    "text": "2.3 dplyr\ndplyr is a package used to manipulate data. Here we will just introduce the most basic functions. We will use nycflights13::flights as the example. This dataset comes from the US Bureau of Transportation Statistics. The document can be found here.\nTo load the dataset, please use the following code.\n\nlibrary(nycflights13)\nflights\n#&gt; # A tibble: 336,776 x 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     1     1      533            529         4      850            830\n#&gt;  3  2013     1     1      542            540         2      923            850\n#&gt;  4  2013     1     1      544            545        -1     1004           1022\n#&gt;  5  2013     1     1      554            600        -6      812            837\n#&gt;  6  2013     1     1      554            558        -4      740            728\n#&gt;  7  2013     1     1      555            600        -5      913            854\n#&gt;  8  2013     1     1      557            600        -3      709            723\n#&gt;  9  2013     1     1      557            600        -3      838            846\n#&gt; 10  2013     1     1      558            600        -2      753            745\n#&gt; # i 336,766 more rows\n#&gt; # i 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n2.3.1 filter()\nfilter() allows you to subset observations based on their values. The first argument is the name of the tibble. The rest are the expressions that filter the data. Please see the following examples.\n\nflights %&gt;% filter(month==1, day==1)\n#&gt; # A tibble: 842 x 19\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     1     1      533            529         4      850            830\n#&gt;  3  2013     1     1      542            540         2      923            850\n#&gt;  4  2013     1     1      544            545        -1     1004           1022\n#&gt;  5  2013     1     1      554            600        -6      812            837\n#&gt;  6  2013     1     1      554            558        -4      740            728\n#&gt;  7  2013     1     1      555            600        -5      913            854\n#&gt;  8  2013     1     1      557            600        -3      709            723\n#&gt;  9  2013     1     1      557            600        -3      838            846\n#&gt; 10  2013     1     1      558            600        -2      753            745\n#&gt; # i 832 more rows\n#&gt; # i 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n2.3.2 select()\nselect() allows you to filter columns. It is very similar to slicing [].\n\n\n2.3.3 mutate()\nmutate() is used to add new columns that are functions of existing columns.\n\nflights %&gt;% mutate(gain=arr_delay-dep_delay, hours=air_time/60, gain_per_hour=gain/hours)\n#&gt; # A tibble: 336,776 x 22\n#&gt;     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt;  1  2013     1     1      517            515         2      830            819\n#&gt;  2  2013     1     1      533            529         4      850            830\n#&gt;  3  2013     1     1      542            540         2      923            850\n#&gt;  4  2013     1     1      544            545        -1     1004           1022\n#&gt;  5  2013     1     1      554            600        -6      812            837\n#&gt;  6  2013     1     1      554            558        -4      740            728\n#&gt;  7  2013     1     1      555            600        -5      913            854\n#&gt;  8  2013     1     1      557            600        -3      709            723\n#&gt;  9  2013     1     1      557            600        -3      838            846\n#&gt; 10  2013     1     1      558            600        -2      753            745\n#&gt; # i 336,766 more rows\n#&gt; # i 14 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, hours &lt;dbl&gt;,\n#&gt; #   gain_per_hour &lt;dbl&gt;\n\nIf you only want to see the new columns, transmute() can be used.\n\nflights %&gt;% transmute(gain=arr_delay-dep_delay, hours=air_time/60, gain_per_hour=gain/hours)\n#&gt; # A tibble: 336,776 x 3\n#&gt;     gain hours gain_per_hour\n#&gt;    &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;\n#&gt;  1     9 3.78           2.38\n#&gt;  2    16 3.78           4.23\n#&gt;  3    31 2.67          11.6 \n#&gt;  4   -17 3.05          -5.57\n#&gt;  5   -19 1.93          -9.83\n#&gt;  6    16 2.5            6.4 \n#&gt;  7    24 2.63           9.11\n#&gt;  8   -11 0.883        -12.5 \n#&gt;  9    -5 2.33          -2.14\n#&gt; 10    10 2.3            4.35\n#&gt; # i 336,766 more rows\n\nHere are an (incomplete) list of supported operators and functions.\n\nArithmetic operators: +, -, *, /, ^.\nModular arithmetic: %/% (integer division), %% (remainder).\nLogs: log(), log2(), log10().\nCumulative and rolling aggregates: cumsum(), cumprod(), cummin(), cummax(), cummean()\nLogical comparisons: &lt;, &lt;=, &gt;, &gt;=, !=.\n\n\n\n2.3.4 summarize() and group_by()\nsummarize() collapses a dataset to a single row. It computes values across all rows. It is usually paired with group_by(). Here are some examples.\n\nExample 2.3  \n\nflights %&gt;% group_by(year, month, day) %&gt;% \n    summarize(delay=mean(dep_delay, na.rm=TRUE))\n#&gt; `summarise()` has grouped output by 'year', 'month'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 365 x 4\n#&gt; # Groups:   year, month [12]\n#&gt;     year month   day delay\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt;  1  2013     1     1 11.5 \n#&gt;  2  2013     1     2 13.9 \n#&gt;  3  2013     1     3 11.0 \n#&gt;  4  2013     1     4  8.95\n#&gt;  5  2013     1     5  5.73\n#&gt;  6  2013     1     6  7.15\n#&gt;  7  2013     1     7  5.42\n#&gt;  8  2013     1     8  2.55\n#&gt;  9  2013     1     9  2.28\n#&gt; 10  2013     1    10  2.84\n#&gt; # i 355 more rows\n\n\n\nExample 2.4  \n\ndelays &lt;- flights %&gt;% \n    group_by(dest) %&gt;% \n    summarize(\n        count=n(), \n        dist=mean(distance, na.rm=TRUE),\n        delay=mean(arr_delay, na.rm=TRUE)\n    ) %&gt;% \n    filter(count&gt;20, dest!='HNL')\ndelays\n#&gt; # A tibble: 96 x 4\n#&gt;    dest  count  dist delay\n#&gt;    &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 ABQ     254 1826   4.38\n#&gt;  2 ACK     265  199   4.85\n#&gt;  3 ALB     439  143  14.4 \n#&gt;  4 ATL   17215  757. 11.3 \n#&gt;  5 AUS    2439 1514.  6.02\n#&gt;  6 AVL     275  584.  8.00\n#&gt;  7 BDL     443  116   7.05\n#&gt;  8 BGR     375  378   8.03\n#&gt;  9 BHM     297  866. 16.9 \n#&gt; 10 BNA    6333  758. 11.8 \n#&gt; # i 86 more rows\n\n\ngroup_by() can also be used together with mutate() and filter().\n\nExample 2.5  \n\nflights %&gt;%\n    group_by(dest) %&gt;%\n    filter(n() &gt; 365) %&gt;%\n    filter(arr_delay &gt; 0) %&gt;%\n    mutate(prop_delay = arr_delay / sum(arr_delay)) %&gt;%\n    select(year:day, dest, arr_delay, prop_delay)\n#&gt; # A tibble: 131,106 x 6\n#&gt; # Groups:   dest [77]\n#&gt;     year month   day dest  arr_delay prop_delay\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1  2013     1     1 IAH          11  0.000111 \n#&gt;  2  2013     1     1 IAH          20  0.000201 \n#&gt;  3  2013     1     1 MIA          33  0.000235 \n#&gt;  4  2013     1     1 ORD          12  0.0000424\n#&gt;  5  2013     1     1 FLL          19  0.0000938\n#&gt;  6  2013     1     1 ORD           8  0.0000283\n#&gt;  7  2013     1     1 LAX           7  0.0000344\n#&gt;  8  2013     1     1 DFW          31  0.000282 \n#&gt;  9  2013     1     1 ATL          12  0.0000400\n#&gt; 10  2013     1     1 DTW          16  0.000116 \n#&gt; # i 131,096 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe already use it in the above examples. This is to compute the number of observations in the current group. This function is implemented specifically for each data source and can only be used from within summarise(), mutate() and filter().",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R for Data Sciences</span>"
    ]
  },
  {
    "objectID": "contents/9/intro.html#ggplot2",
    "href": "contents/9/intro.html#ggplot2",
    "title": "2  R for Data Sciences",
    "section": "2.4 ggplot2",
    "text": "2.4 ggplot2\nThis is the graphing package for R in tidyverse. ggplot2 implements the grammar of graphics, a coherent system for describing and building graphs. With ggplot2, you can do more faster by learning one system and applying it in many places. The main function is ggplot().\nggplot2 will be uploaded with tidyverse.\n\nlibrary(tidyverse)\n\nWe use the dataset mpg as the example. This dataset comes with ggplot2. Once you load ggplot2 you can directly find the dataset by typing mpg.\n\nmpg\n#&gt; # A tibble: 234 x 11\n#&gt;    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n#&gt;    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt;  1 audi         a4           1.8  1999     4 auto~ f        18    29 p     comp~\n#&gt;  2 audi         a4           1.8  1999     4 manu~ f        21    29 p     comp~\n#&gt;  3 audi         a4           2    2008     4 manu~ f        20    31 p     comp~\n#&gt;  4 audi         a4           2    2008     4 auto~ f        21    30 p     comp~\n#&gt;  5 audi         a4           2.8  1999     6 auto~ f        16    26 p     comp~\n#&gt;  6 audi         a4           2.8  1999     6 manu~ f        18    26 p     comp~\n#&gt;  7 audi         a4           3.1  2008     6 auto~ f        18    27 p     comp~\n#&gt;  8 audi         a4 quattro   1.8  1999     4 manu~ 4        18    26 p     comp~\n#&gt;  9 audi         a4 quattro   1.8  1999     4 auto~ 4        16    25 p     comp~\n#&gt; 10 audi         a4 quattro   2    2008     4 manu~ 4        20    28 p     comp~\n#&gt; # i 224 more rows\n\nThe syntax for ggplot() is ::: {.cell}\nggplot(data = &lt;DATA&gt;) +\n    &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;))\n:::\nggplot(data=&lt;DATA&gt;) create a plot without any geometric elements. It simply creates the canvas paired with the dataset.\nThen you add one or more layers to ggplot() to complete the graph. The function &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) adds a layer to the plot. You may add as many layers as you want.\nEach geom function takes a mapping argument. This defines how variables in the dataset are mapped to visual properties. mapping is always paired with aes(x=, y=). This\nHere is a quick example.\n\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy))\n\n\n\n\n\n\n\n\n\n2.4.1 Aesthetic mappings\nAn aesthetic is a visual property of the objects in your plot. It include things like the size, the shape or the color of the points. The variables set in aes() will change the aesthetic apperance of the geometric objects according to the variables. If the variables are set outside aes(), the apperance will be fixed. Please see the following examples.\nNote that the variables in aes() other than x and y will automatically get legends.\n\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy), color = \"blue\")\n\n\n\n\n\n\n\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy, color = class))\n\n\n\n\n\n\n\n\n\n\n2.4.2 facet\nFor categorical data, you can split the plot into facets. This facet function will be attached as a layer followed by a + sign.\n\nTo facet your plot by a single variable, use facet_wrap(). The first argument should be a formula, which you create with ~ followed by a variable name.\nTo facet your plot by two variables, use facet_grid(). The first argument is a formula which contains two variable names separated by a ~.\n\n\nExample 2.6  \n\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy)) +\n    facet_wrap(~ class, nrow = 2)\n\n\n\n\n\n\n\n\nYou may look at the variables to see the relations with the plot.\n\nunique(mpg$class)\n#&gt; [1] \"compact\"    \"midsize\"    \"suv\"        \"2seater\"    \"minivan\"   \n#&gt; [6] \"pickup\"     \"subcompact\"\n\n\n\nExample 2.7  \n\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy)) +\n    facet_grid(drv ~ cyl)\n\n\n\n\n\n\n\n\nYou may look at the variables to see the relations with the plot.\n\nunique(mpg$drv)\n#&gt; [1] \"f\" \"4\" \"r\"\nunique(mpg$cyl)\n#&gt; [1] 4 6 8 5\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe ~ symbol is used to define a formula. The formula is a R object, which provide the pattern of a “formula”. Therefore drv~cyl means that drv is a function of cyl.\n\n\n\n\n2.4.3 geom objects\nA geom is the geometrical object that a plot uses to represent data. When drawing plots, you just need to attach those geometrical objects to a ggplot canvas with + symbol. Some of the geometrical objects can automatically do statistical transformations. The statistical transformations is short for stat, and the stat argument in those geom will show which statistical transformations are applied.\n\ngeom_point() draws scatter plot.\ngeom_smooth() draws smooth line approximation.\ngeom_bar() draws bar plot.\ngeom_histogram() draws histogram.\n\nThe arguments can be written in ggplot(). All the later geom will get those arguments from ggplot(). If the arguments are written again in geom object, it will override the ggplot() arguments.\n\nExample 2.8  \n\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy))\n\n\n\n\n\n\n\n\nggplot(data = mpg) +\n    geom_smooth(mapping = aes(x = displ, y = hwy), formula = y ~ x, method = \"loess\")\n\n\n\n\n\n\n\n\nggplot(data = mpg) +\n    geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv), formula = y ~ x, method = \"loess\")\n\n\n\n\n\n\n\n\nggplot(data = mpg) +\n    geom_point(mapping = aes(x = displ, y = hwy)) +\n    geom_smooth(mapping = aes(x = displ, y = hwy), formula = y ~ x, method = \"loess\")\n\n\n\n\n\n\n\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n    geom_point(mapping = aes(color = class)) +\n    geom_smooth(\n        data = filter(mpg, class == \"subcompact\"),\n        se = FALSE, \n        formula = y ~ x, method = \"loess\"\n        )",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R for Data Sciences</span>"
    ]
  },
  {
    "objectID": "contents/9/intro.html#exercises",
    "href": "contents/9/intro.html#exercises",
    "title": "2  R for Data Sciences",
    "section": "2.5 Exercises",
    "text": "2.5 Exercises\n\nExercise 2.1 How can you tell if an object is a tibble?\n\n\nExercise 2.2 Compare and contrast the following operations on a data.frame and equivalent tibble. What is different? Why might the default data frame behaviors cause you frustration?\n\ndf &lt;- data.frame(abc = 1, xyz = \"a\")\ndf$x\ndf[, \"xyz\"]\ndf[, c(\"abc\", \"xyz\")]\n\n\n\nExercise 2.3 If you have the name of a variable stored in an object, e.g., var &lt;- \"xyz\", how can you extract the reference variable from a tibble? You may use the following codes to get a tibble.\n\ntbl &lt;- tibble(abc = 1, xyz = \"a\")\n\n\n\nExercise 2.4 Practice referring to nonsyntactic names in the following data.frame by:\n\nExtracting the variable called 1.\nCreating a new column called 3, which is 2 divided by 1.\nRenaming the columns to one, two, and three:\n\n\nannoying &lt;- tibble(\n`1` = 1:10,\n`2` = `1` * 2 + rnorm(length(`1`))\n)\n\n\n\nExercise 2.5 Both unite() and separate() have a remove argument. What does it do? Why would you set it to FALSE?\n\n\nExercise 2.6 Use flights dataset. Currently dep_time and sched_dep_time are convenient to look at, but hard to compute with because they’re not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight.\n\n\n\n\n\nExercise 2.7 Please make the following data tidy.\n\nlibrary(tidyverse)\ndf &lt;- tibble(Day=1:5, `Plant_A_Height (cm)`=c(0.5, 0.7, 0.9, 1.3, 1.8), `Plant_B_Height (cm)`=c(0.7, 1, 1.5, 1.8, 2.2))\n\n\n\nExercise 2.8 Please use the flights dataset. Please find all flights that :\n\nHad an arrival delay of two or more hours.\nFlew to IAH or HOU.\nWere operated by United, American or Delta.\nDeparted in summer (July, August, and September).\nArrived more than two hours late, but didn’t leave late.\nWere delayed by at least an hour, but made up over 30 minutes in flight.\nDeparted between midnight and 6 a.m. (inclusive).\n\n\n\nExercise 2.9 Re-create the R code necessary to generate the following graphs. The dataset is mpg.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[1] Wickham, H. and Grolemund, G. (2017). R for data science: Import, tidy, transform, visualize, and model data. O’Reilly Media.",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R for Data Sciences</span>"
    ]
  },
  {
    "objectID": "contents/10/intro.html",
    "href": "contents/10/intro.html",
    "title": "3  Projects with R",
    "section": "",
    "text": "3.1 WHO TB dataset\nLet us explore the tuberculosis cases data. The dataset is provided by WHO and can be downloaded from here. tidyr also provides the dataset. You may directly get the dataset after you load tidyr from tidyverse. The variable description can be found from tidyr documentations.\nlibrary(tidyverse)\n#&gt; Warning: package 'tidyverse' was built under R version 4.1.3\n#&gt; Warning: package 'tibble' was built under R version 4.1.3\n#&gt; Warning: package 'tidyr' was built under R version 4.1.3\n#&gt; Warning: package 'readr' was built under R version 4.1.3\n#&gt; Warning: package 'purrr' was built under R version 4.1.3\n#&gt; Warning: package 'dplyr' was built under R version 4.1.3\n#&gt; Warning: package 'stringr' was built under R version 4.1.3\n#&gt; Warning: package 'forcats' was built under R version 4.1.3\n#&gt; -- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\n#&gt; v dplyr     1.1.1     v readr     2.1.4\n#&gt; v forcats   1.0.0     v stringr   1.5.0\n#&gt; v ggplot2   3.4.4     v tibble    3.2.1\n#&gt; v lubridate 1.9.3     v tidyr     1.3.0\n#&gt; v purrr     1.0.1     \n#&gt; -- Conflicts ------------------------------------------ tidyverse_conflicts() --\n#&gt; x dplyr::filter() masks stats::filter()\n#&gt; x dplyr::lag()    masks stats::lag()\n#&gt; i Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nwho\n#&gt; # A tibble: 7,240 x 60\n#&gt;    country  iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\n#&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n#&gt;  1 Afghani~ AF    AFG    1980          NA           NA           NA           NA\n#&gt;  2 Afghani~ AF    AFG    1981          NA           NA           NA           NA\n#&gt;  3 Afghani~ AF    AFG    1982          NA           NA           NA           NA\n#&gt;  4 Afghani~ AF    AFG    1983          NA           NA           NA           NA\n#&gt;  5 Afghani~ AF    AFG    1984          NA           NA           NA           NA\n#&gt;  6 Afghani~ AF    AFG    1985          NA           NA           NA           NA\n#&gt;  7 Afghani~ AF    AFG    1986          NA           NA           NA           NA\n#&gt;  8 Afghani~ AF    AFG    1987          NA           NA           NA           NA\n#&gt;  9 Afghani~ AF    AFG    1988          NA           NA           NA           NA\n#&gt; 10 Afghani~ AF    AFG    1989          NA           NA           NA           NA\n#&gt; # i 7,230 more rows\n#&gt; # i 52 more variables: new_sp_m4554 &lt;dbl&gt;, new_sp_m5564 &lt;dbl&gt;,\n#&gt; #   new_sp_m65 &lt;dbl&gt;, new_sp_f014 &lt;dbl&gt;, new_sp_f1524 &lt;dbl&gt;,\n#&gt; #   new_sp_f2534 &lt;dbl&gt;, new_sp_f3544 &lt;dbl&gt;, new_sp_f4554 &lt;dbl&gt;,\n#&gt; #   new_sp_f5564 &lt;dbl&gt;, new_sp_f65 &lt;dbl&gt;, new_sn_m014 &lt;dbl&gt;,\n#&gt; #   new_sn_m1524 &lt;dbl&gt;, new_sn_m2534 &lt;dbl&gt;, new_sn_m3544 &lt;dbl&gt;,\n#&gt; #   new_sn_m4554 &lt;dbl&gt;, new_sn_m5564 &lt;dbl&gt;, new_sn_m65 &lt;dbl&gt;, ...\nBased on the description of varaibles, we understand that\nTherefore to clean the data, we need the following steps.\nThen we use stringr::str_replace() to replace newrel by new_rel.\nwholonger2 &lt;- wholonger %&gt;% mutate(key=str_replace(group, 'newrel', 'new_rel'))\nWe could use the pipe symbol to connect all the above steps.",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Projects with R</span>"
    ]
  },
  {
    "objectID": "contents/10/intro.html#who-tb-dataset",
    "href": "contents/10/intro.html#who-tb-dataset",
    "title": "3  Projects with R",
    "section": "",
    "text": "country, iso2, iso3 are all refered to country names (and thus they are redundant).\nColumns after year, like new_sp_m014 etc., are counts of new TB cases recorded by groups. The code has three parts, most of which are separated by _ (but there are some exceptions).\n\nThe first part is always new.\nThe second part is a code for method of diagnosis:\n\nrel = relapse,\nsn = negative pulmonary smear,\nsp = positive pulmonary smear,\nep = extrapulmonary.\n\nThe third part is a code for gender (f = female, m = male) and a code for age group:\n\n014 = 0-14 yrs of age,\n1524 = 15-24 years of age,\n2534 = 25 to 34 years of age,\n3544 = 35 to 44 years of age,\n4554 = 45 to 54 years of age,\n5564 = 55 to 64 years of age,\n65 = 65 years of age or older\n\n\n\n\n\nExample 3.1 Gather together all the columns from new_sp_m014 to newrel_f65.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nwholonger &lt;- who %&gt;% pivot_longer(cols=5:60, names_to='group', values_to='counts')\n\n\n\n\n\n\n\n\nExample 3.2 Parse the column group into columns.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nwholonger3 &lt;- wholonger2 %&gt;% \n        separate(key, into=c('new', 'type', 'genderage'), sep='_') %&gt;% \n        separate(genderage, into=c('gender', 'age'), sep=1)\n\n\n\n\n\n\nExample 3.3 Pick the columns that matters.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ntidywho &lt;- wholonger3[c('country', 'year', 'type', 'gender', 'age', 'counts')]\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ntidywho &lt;- who %&gt;% \n    pivot_longer(cols=5:60, names_to='group', values_to='counts') %&gt;% \n    mutate(key=str_replace(group, 'newrel', 'new_rel')) %&gt;% \n    separate(key, into=c('new', 'type', 'genderage'), sep='_') %&gt;% \n    separate(genderage, into=c('gender', 'age'), sep=1) %&gt;% \n    select('country', 'year', 'type', 'gender', 'age', 'counts')",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Projects with R</span>"
    ]
  },
  {
    "objectID": "contents/10/intro.html#us-babynames",
    "href": "contents/10/intro.html#us-babynames",
    "title": "3  Projects with R",
    "section": "3.2 US Babynames",
    "text": "3.2 US Babynames\nLet us use R to solve the babynames dataset again.\nThe first task is to read those files.\n\nExample 3.4 Please read files and put the data into one tibble. The dataset can be downloaded from here as a zip file.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\npath &lt;- 'assessts/datasets/babynames/yob'\ndfs &lt;- map(1880:2010, function(y){\n    filepath &lt;- paste0(path, as.character(y), '.txt')\n    df_individual &lt;- tibble(read.csv(filepath, header=FALSE))\n    names(df_individual) &lt;- c('name', 'gender', 'counts')\n    df_individual$year &lt;- y\n    df_individual\n})\ndf &lt;- bind_rows(dfs)\n\n\n\n\n\n\nExample 3.5 Please plot the total births by gender and year.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ndf %&gt;% \n    group_by(gender, year) %&gt;% \n    summarize(total_num=sum(counts)) %&gt;% \n    ggplot() +\n        geom_line(mapping = aes(x=year, y=total_num, color=gender))\n#&gt; `summarise()` has grouped output by 'gender'. You can override using the\n#&gt; `.groups` argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 3.6 Please compute the proportions of each name relateive to the total number of births per year per gender.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ndf %&gt;% \n    group_by(gender, year) %&gt;% \n    mutate(prop=counts/sum(counts))\n#&gt; # A tibble: 1,690,784 x 5\n#&gt; # Groups:   gender, year [262]\n#&gt;    name      gender counts  year   prop\n#&gt;    &lt;chr&gt;     &lt;chr&gt;   &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;\n#&gt;  1 Mary      F        7065  1880 0.0776\n#&gt;  2 Anna      F        2604  1880 0.0286\n#&gt;  3 Emma      F        2003  1880 0.0220\n#&gt;  4 Elizabeth F        1939  1880 0.0213\n#&gt;  5 Minnie    F        1746  1880 0.0192\n#&gt;  6 Margaret  F        1578  1880 0.0173\n#&gt;  7 Ida       F        1472  1880 0.0162\n#&gt;  8 Alice     F        1414  1880 0.0155\n#&gt;  9 Bertha    F        1320  1880 0.0145\n#&gt; 10 Sarah     F        1288  1880 0.0142\n#&gt; # i 1,690,774 more rows\n\n\n\n\n\n\nExample 3.7 We would like to keep the first 100 names (by counts) in each year and save it as a new tibble top100.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ntop100 &lt;- df %&gt;% \n        group_by(gender, year) %&gt;% \n        top_n(100, wt=counts)\n\n\n\n\n\n\nExample 3.8 Please draw the trend of John, Harry, Mary in top100 by counts.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nnamelist &lt;- c('John', 'Harry', 'Mary')\ntop100 %&gt;% \n    filter(name %in% namelist) %&gt;% \n    ggplot() +\n        geom_line(mapping=aes(x=year, y=counts, color=name))\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 3.9 Now we would like to analyze the ending of names. Please get a tibble that contains the counts of ending letter per year per gender. We mainly focus on 1910, 1960 and 2010.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ndf %&gt;% \n    filter(year %in% c(1910, 1960, 2010)) %&gt;% \n    mutate(ending=str_sub(name, -1, -1), \n           year=as.factor(year)) %&gt;% \n    group_by(gender, year, ending) %&gt;% \n    summarise(ending_counts=sum(counts)) %&gt;% \n    ggplot() +\n        geom_col(\n            mapping = aes(\n                x=ending, \n                y=ending_counts, \n                fill=year,\n                ), \n            position = \"dodge\",\n        ) +\n        facet_wrap(~gender, nrow=2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 3.10 Please draw the line plot to show the trending of certain letters through years. Here we choose d, n and y.\n\n\n\n\n\n\nTip\n\n\n\n\n\n\ndf %&gt;% \n    mutate(ending=str_sub(name, -1, -1)) %&gt;% \n    group_by(year, ending) %&gt;% \n    summarise(ending_counts=sum(counts)) %&gt;% \n    filter(ending %in% c('d', 'n', 'y')) %&gt;% \n    ggplot() +\n        geom_line(\n            mapping = aes(\n                x=year, \n                y=ending_counts, \n                color=ending\n            )\n        )",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Projects with R</span>"
    ]
  },
  {
    "objectID": "contents/10/intro.html#references",
    "href": "contents/10/intro.html#references",
    "title": "3  Projects with R",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Part I: Base R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Projects with R</span>"
    ]
  }
]